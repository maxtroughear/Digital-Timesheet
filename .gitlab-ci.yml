image: docker:latest

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

# setup dynamic variables
default:
  before_script:
    - |
      if [[ -z "$CI_COMMIT_TAG" ]]; then
        export CI_APPLICATION_REPOSITORY=${CI_APPLICATION_REPOSITORY:-$CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG}
        export CI_APPLICATION_TAG=${CI_APPLICATION_TAG:-$CI_COMMIT_SHA}
      else
        export CI_APPLICATION_REPOSITORY=${CI_APPLICATION_REPOSITORY:-$CI_REGISTRY_IMAGE}
        export CI_APPLICATION_TAG=${CI_APPLICATION_TAG:-$CI_COMMIT_TAG}
      fi
    - export ENVIRONMENT_HOST=$(echo "$CI_ENVIRONMENT_URL" | sed -e 's|^[^/]*//||')
    - export APPLICATION_DIRECTORY=${CI_PROJECT_PATH_SLUG}-${CI_ENVIRONMENT_SLUG}
    # export variables to .env
    - chmod +x ./setup-env.sh
    - ./setup-env.sh

stages:
  - test
  - build
  - review
  - staging
  - deploy

cache:
  paths:
    - client/node_modules/

# testing not setup

.test: &test_template
  services:
    - redis:alpine
  stage: test
  except:
    variables:
      - $TEST_DISABLED

test:
  <<: *test_template
  script:
    - npm install
    - npm install --only=dev
    - npm test

test_echo:
  <<: *test_template
  script:
    - echo "$CI_DEFAULT_BRANCH"

build-frontend:
  stage: build
  image:
    name: docker:stable
  services:
    - docker:stable-dind
  script:
    - cd ./client
    - docker login -u "${CI_REGISTRY_USER}" -p "${CI_REGISTRY_PASSWORD}" "${CI_REGISTRY}"
    - >
      docker image pull "${CI_APPLICATION_REPOSITORY}-frontend:${CI_COMMIT_BEFORE_SHA}" ||
      docker image pull "${CI_APPLICATION_REPOSITORY}-frontend:latest" ||
      docker image pull "${CI_APPLICATION_REPOSITORY}-frontend:edge" ||
      true
    - >
      docker build
      -f Dockerfile.prod
      --cache-from "${CI_APPLICATION_REPOSITORY}-frontend:${CI_COMMIT_BEFORE_SHA}"
      --cache-from "${CI_APPLICATION_REPOSITORY}-frontend:latest"
      --cache-from "${CI_APPLICATION_REPOSITORY}-frontend:edge"
      -t "${CI_APPLICATION_REPOSITORY}-frontend:latest"
      -t "${CI_APPLICATION_REPOSITORY}-frontend:${CI_APPLICATION_TAG}"
      -t "${CI_APPLICATION_REPOSITORY}-frontend:edge"
      --build-arg REACT_APP_API_URI
      .
    - test ! -z "${CI_COMMIT_TAG}" && docker push "${CI_APPLICATION_REPOSITORY}-frontend:latest"
    - docker push "${CI_APPLICATION_REPOSITORY}-frontend:${CI_APPLICATION_TAG}"
    - docker push "${CI_APPLICATION_REPOSITORY}-frontend:edge"

# build-reverse-proxy:
#   stage: build
#   image:
#     name: docker:stable
#   services:
#     - docker:stable-dind
#   script:
#     - cd ./reverse-proxy
#     - docker login -u "${CI_REGISTRY_USER}" -p "${CI_REGISTRY_PASSWORD}" "${CI_REGISTRY}"
#     - >
#       docker image pull "${CI_APPLICATION_REPOSITORY}-reverse-proxy:${CI_COMMIT_BEFORE_SHA}" ||
#       docker image pull "${CI_APPLICATION_REPOSITORY}-reverse-proxy:latest" ||
#       true
#     - >
#       docker build
#       --cache-from "${CI_APPLICATION_REPOSITORY}-reverse-proxy:${CI_COMMIT_BEFORE_SHA}"
#       --cache-from "${CI_APPLICATION_REPOSITORY}-reverse-proxy:latest"
#       -t "${CI_APPLICATION_REPOSITORY}-reverse-proxy:latest"
#       -t "${CI_APPLICATION_REPOSITORY}-reverse-proxy:${CI_APPLICATION_TAG}"
#       -t "${CI_APPLICATION_REPOSITORY}-reverse-proxy:edge"
#       .
#     - test ! -z "${CI_COMMIT_TAG}" && docker push "${CI_APPLICATION_REPOSITORY}-reverse-proxy:latest"
#     - docker push "${CI_APPLICATION_REPOSITORY}-reverse-proxy:${CI_APPLICATION_TAG}"
#     - docker push "${CI_APPLICATION_REPOSITORY}-reverse-proxy:edge"

build-api:
  stage: build
  image:
    name: docker:stable
  services:
    - docker:stable-dind
  script:
    - cd ./go-server
    - docker login -u "${CI_REGISTRY_USER}" -p "${CI_REGISTRY_PASSWORD}" "${CI_REGISTRY}"
    - >
      docker image pull "${CI_APPLICATION_REPOSITORY}-api:${CI_COMMIT_BEFORE_SHA}" ||
      docker image pull "${CI_APPLICATION_REPOSITORY}-api:latest" ||
      docker image pull "${CI_APPLICATION_REPOSITORY}-api:edge" ||
      true
    - >
      docker build
      --cache-from "${CI_APPLICATION_REPOSITORY}-api:${CI_COMMIT_BEFORE_SHA}"
      --cache-from "${CI_APPLICATION_REPOSITORY}-api:latest"
      --cache-from "${CI_APPLICATION_REPOSITORY}-api:edge"
      -t "${CI_APPLICATION_REPOSITORY}-api:latest"
      -t "${CI_APPLICATION_REPOSITORY}-api:${CI_APPLICATION_TAG}"
      -t "${CI_APPLICATION_REPOSITORY}-api:edge"
      .
    - test ! -z "${CI_COMMIT_TAG}" && docker push "${CI_APPLICATION_REPOSITORY}-api:latest"
    - docker push "${CI_APPLICATION_REPOSITORY}-api:${CI_APPLICATION_TAG}"
    - docker push "${CI_APPLICATION_REPOSITORY}-api:edge"

review:
  stage: review
  extends: .deploy
  environment:
    name: review/${CI_COMMIT_REF_NAME}
    url: http://review-${CI_COMMIT_REF_SLUG}.${BASE_DOMAIN}
    on_stop: stop_review
  only:
    refs:
      - branches
    variables:
      - $REVIEW_ENABLED == "true"
  except:
    refs:
      - master
      - tags

stop_review:
  stage: review
  extends: .stop_deploy
  environment:
    name: review/${CI_COMMIT_REF_NAME}
    action: stop
  variables:
    GIT_STRATEGY: none
  when: manual
  only:
    refs:
      - branches
    variables:
      - $REVIEW_ENABLED == "true"
  except:
    refs:
      - master
      - tags

staging:
  stage: staging
  extends: .deploy
  environment:
    name: staging
    url: https://edge.$BASE_DOMAIN
  only:
    refs:
      - master
    variables:
      - $STAGING_ENABLED == "true"

production:
  stage: deploy
  extends: .deploy
  environment:
    name: production
    url: https://$BASE_DOMAIN
  allow_failure: false
  when: manual
  only:
    refs:
      - master
    variables:
      - $PRODUCTION_ENABLED == "true"

.deploy:
  image: registry.maxtroughear.dev/max.troughear/docker-images/alpine-curl
  script:
    - echo "Updating API Service"
    - curl -X POST ${SERVICE_WEBHOOK_API}
    - echo "Updating Frontend Service"
    - curl -X POST ${SERVICE_WEBHOOK_FRONTEND}
    - exit 0

.stop_deploy:
  image: kroniak/ssh-client
  script:
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "${SERVER_PRIVATE_KEY}" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - eval "$(ssh-agent -s)"
    - ssh-add ~/.ssh/id_rsa
    - ssh-keyscan -H ${SERVER_IP} >> ~/.ssh/known_hosts
    - >
      ssh ${SERVER_USER}@${SERVER_IP} "cd ${APPLICATION_DIRECTORY}/;
      docker-compose -f docker-compose.yml -f docker-compose.prod.yml down || true"
